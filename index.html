<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SNAKE: ULTIMATE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top {
            padding: 30px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .score-container { text-align: left; }
        .score-label { font-size: 16px; color: #00f3ff; opacity: 0.7; letter-spacing: 2px; }
        .score-value { font-size: 48px; font-weight: 800; color: #fff; text-shadow: 0 0 20px #00f3ff; line-height: 1; }

        .audio-viz { display: flex; gap: 3px; align-items: flex-end; height: 30px; }
        .bar { width: 4px; background: #ff0055; animation: equalizer 0.5s infinite; }
        @keyframes equalizer { 0% { height: 20%; } 50% { height: 100%; } 100% { height: 20%; } }

        .hud-bottom {
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .nitro-label { color: #ffcc00; font-size: 14px; letter-spacing: 4px; font-weight: 700; text-shadow: 0 0 10px #ffcc00; }
        .nitro-bar-container { display: flex; gap: 8px; }
        .nitro-cell { width: 60px; height: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 204, 0, 0.3); transform: skewX(-20deg); position: relative; overflow: hidden; }
        .nitro-fill { position: absolute; top: 0; left: 0; bottom: 0; width: 0%; background: #ffcc00; box-shadow: 0 0 15px #ffcc00; transition: width 0.1s linear; }

        .center-panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(5, 5, 10, 0.9);
            border: 1px solid rgba(0, 243, 255, 0.4);
            padding: 50px 80px;
            pointer-events: auto;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 100px rgba(0, 243, 255, 0.1), inset 0 0 50px rgba(0, 0, 0, 0.8);
            z-index: 50;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        h1 {
            font-size: 72px; margin: 0; font-weight: 800; font-style: italic;
            background: linear-gradient(135deg, #fff 0%, #00f3ff 50%, #ff00ff 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 50px rgba(0, 243, 255, 0.5); letter-spacing: -3px; line-height: 0.9;
        }

        p { color: #8899a6; font-size: 18px; margin: 20px 0 40px 0; letter-spacing: 1px; }

        .key-hint {
            display: inline-block; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
            padding: 2px 8px; border-radius: 4px; color: #fff; font-weight: bold; font-size: 0.9em; margin: 0 2px;
        }

        .btn {
            background: transparent; border: 2px solid #00f3ff; color: #00f3ff;
            padding: 18px 60px; font-size: 24px; font-family: inherit; font-weight: 800;
            cursor: pointer; text-transform: uppercase; letter-spacing: 4px; transition: 0.2s;
            position: relative; overflow: hidden;
        }
        .btn:hover { background: #00f3ff; color: #000; box-shadow: 0 0 60px #00f3ff; }

        #scanline {
            position: fixed; left: 0; top: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 99; opacity: 0.6;
        }

        #mobile-controls { display: none; position: absolute; bottom: 0; width: 100%; height: 100%; z-index: 20; }
        .touch-left, .touch-right { width: 50%; height: 100%; float: left; }
        .touch-dash { 
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 100px; height: 100px; border-radius: 50%; border: 2px solid #ffcc00;
            background: rgba(255, 204, 0, 0.1); pointer-events: auto;
            display: flex; align-items: center; justify-content: center; color: #ffcc00; font-weight: bold;
        }

        @media (max-width: 768px) {
            #mobile-controls { display: block; }
            h1 { font-size: 48px; }
            .center-panel { width: 85%; padding: 40px; }
            .hud-top { padding: 20px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="scanline"></div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-container">
                <div class="score-label">SYNC RATE</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="audio-viz">
                <div class="bar" style="animation-duration: 0.4s"></div>
                <div class="bar" style="animation-duration: 0.6s"></div>
                <div class="bar" style="animation-duration: 0.3s"></div>
                <div class="bar" style="animation-duration: 0.5s"></div>
            </div>
        </div>

        <div id="start-screen" class="center-panel">
            <h1>NEON<br>ULTIMATE</h1>
            <p>
                <span class="key-hint">←</span> <span class="key-hint">→</span> TURN <span style="color:#aaa">|</span> 
                <span class="key-hint">↓</span> REPEAT TURN (U-TURN)<br><br>
                <span class="key-hint" style="color:#ffcc00; border-color:#ffcc00">↑ HOLD</span> FOR HYPER DASH<br>
            </p>
            <button class="btn" id="btn-start">SYSTEM LINK</button>
        </div>

        <div id="game-over-screen" class="center-panel" style="display: none;">
            <h1 style="background: linear-gradient(90deg, #ff0055, #ff4400); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">FATAL ERROR</h1>
            <p>FINAL SYNC: <span id="final-score" style="color:#fff; font-weight:bold;">0</span></p>
            <button class="btn" id="btn-restart" style="border-color: #ff0055; color: #ff0055;">REBOOT</button>
        </div>

        <div class="hud-bottom">
            <div class="nitro-label">HYPER CHARGE</div>
            <div class="nitro-bar-container">
                <div class="nitro-cell"><div class="nitro-fill" id="cell-0"></div></div>
                <div class="nitro-cell"><div class="nitro-fill" id="cell-1"></div></div>
                <div class="nitro-cell"><div class="nitro-fill" id="cell-2"></div></div>
                <div class="nitro-cell"><div class="nitro-fill" id="cell-3"></div></div>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="touch-left" id="t-left"></div>
            <div class="touch-right" id="t-right"></div>
            <div class="touch-dash" id="t-dash">DASH</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.5;
                
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -10;
                this.compressor.ratio.value = 12;
                this.compressor.release.value = 0.25;

                this.reverb = this.createReverb(2.0);
                this.reverbGain = this.ctx.createGain();
                this.reverbGain.gain.value = 0.3;

                this.master.connect(this.compressor);
                this.compressor.connect(this.ctx.destination);
                this.master.connect(this.reverb);
                this.reverb.connect(this.reverbGain);
                this.reverbGain.connect(this.ctx.destination);

                this.isPlaying = false;
                this.tempo = 128;
                this.nextNoteTime = 0;
                this.beat = 0;
                this.dashIntensity = 0;
                this.score = 0;
            }
            createReverb(duration) {
                const len = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for(let c=0; c<2; c++) {
                    const d = buffer.getChannelData(c);
                    for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 2);
                }
                const conv = this.ctx.createConvolver();
                conv.buffer = buffer;
                return conv;
            }
            resume() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.schedule();
            }
            stop() {
                this.isPlaying = false;
                this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            }
            setDashState(isDashing) {
                this.dashIntensity = isDashing ? 1 : 0;
            }
            schedule() {
                if(!this.isPlaying) return;
                const secPerBeat = 60.0 / this.tempo;
                const lookahead = 0.1;
                while(this.nextNoteTime < this.ctx.currentTime + lookahead) {
                    this.playTick(this.nextNoteTime, this.beat);
                    this.nextNoteTime += secPerBeat / 4;
                    this.beat++;
                }
                setTimeout(() => this.schedule(), 25);
            }
            playTick(t, beat) {
                const step16 = beat % 16;
                if(step16 % 4 === 0) this.synthKick(t);
                if(step16 % 4 === 2 || step16 % 4 === 3) {
                    const freq = this.dashIntensity ? 110 : 55; 
                    this.synthBass(t, freq);
                }
                if(step16 === 4 || step16 === 12) this.synthSnare(t);
                if(step16 % 2 === 0) {
                    if(this.dashIntensity || this.score > 50) this.synthHihat(t, step16 % 4 === 2 ? 0.1 : 0.05);
                    else if(step16 % 4 === 2) this.synthHihat(t, 0.05);
                }
                if(this.score >= 0) { 
                    const scale = [0, 3, 5, 7, 10]; 
                    const root = 440; 
                    const noteIdx = (beat * 3) % 5;
                    const octave = this.dashIntensity ? 2 : 1; 
                    if(step16 % 2 === 0) {
                        const freq = root * Math.pow(2, scale[noteIdx]/12 - 1) * octave;
                        this.synthArp(t, freq, this.dashIntensity ? 0.15 : 0.05);
                    }
                }
            }
            synthKick(t) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.master);
                osc.frequency.setValueAtTime(150, t);
                osc.frequency.exponentialRampToValueAtTime(0.01, t+0.5);
                gain.gain.setValueAtTime(1.0, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t+0.5);
                osc.start(t); osc.stop(t+0.5);
            }
            synthBass(t, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                const gain = this.ctx.createGain();
                osc.connect(filter); filter.connect(gain); gain.connect(this.master);
                osc.frequency.setValueAtTime(freq, t);
                const filterQ = this.dashIntensity ? 2000 : 400;
                filter.frequency.setValueAtTime(100, t);
                filter.frequency.exponentialRampToValueAtTime(filterQ, t+0.1);
                gain.gain.setValueAtTime(0.4, t);
                gain.gain.linearRampToValueAtTime(0, t+0.2);
                osc.start(t); osc.stop(t+0.2);
            }
            synthSnare(t) {
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate*0.2, this.ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for(let i=0; i<data.length; i++) data[i] = Math.random()*2-1;
                const src = this.ctx.createBufferSource();
                src.buffer = noiseBuffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 1000;
                const gain = this.ctx.createGain();
                src.connect(filter); filter.connect(gain); gain.connect(this.master);
                gain.connect(this.reverb);
                gain.gain.setValueAtTime(0.5, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t+0.2);
                src.start(t);
            }
            synthHihat(t, vol) {
                const osc = this.ctx.createOscillator();
                osc.type = 'square';
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 8000;
                const gain = this.ctx.createGain();
                osc.connect(filter); filter.connect(gain); gain.connect(this.master);
                osc.frequency.setValueAtTime(800 + Math.random()*200, t); 
                gain.gain.setValueAtTime(vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t+0.05);
                osc.start(t); osc.stop(t+0.05);
            }
            synthArp(t, freq, vol) {
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle'; 
                const gain = this.ctx.createGain();
                const delay = this.ctx.createDelay();
                delay.delayTime.value = 0.25; 
                const delayGain = this.ctx.createGain();
                delayGain.gain.value = 0.4;
                osc.connect(gain);
                gain.connect(this.master); gain.connect(delay);
                delay.connect(delayGain); delayGain.connect(this.master);
                delayGain.connect(delay); 
                osc.frequency.setValueAtTime(freq, t);
                gain.gain.setValueAtTime(vol, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t+0.3);
                osc.start(t); osc.stop(t+0.5); 
            }
            playSound(type) {
                const t = this.ctx.currentTime;
                if(type === 'eat') {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1000, t);
                    osc.frequency.linearRampToValueAtTime(2000, t+0.1);
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.5, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t+0.1);
                    osc.connect(gain); gain.connect(this.master);
                    osc.start(t); osc.stop(t+0.1);
                }
            }
        }

        // --- GAME LOGIC ---
        const GRID_SIZE = 40;
        const BASE_SPEED = 0.08;
        const DASH_SPEED_MULT = 2.5;
        const MAX_DASH_FUEL = 4.0;
        const DASH_CONSUMPTION = 0.5;
        
        let scene, camera, renderer, composer, rgbShiftPass;
        let snakeGroup, cityGroup, particles;
        let snakeData = [];
        let direction = new THREE.Vector3(0, 0, -1);
        
        // ** 입력 큐 시스템 **
        let inputQueue = [];
        let lastTurnAction = null; // 'left' or 'right'

        let foodMesh;
        let gameState = {
            isPlaying: false, score: 0, speed: BASE_SPEED,
            dashFuel: 0, isDashing: false
        };
        let lastTime = 0, moveTimer = 0, audioEngine;

        class ParticleSystem {
            constructor(scene) {
                this.particles = [];
                this.scene = scene;
                this.geometry = new THREE.TetrahedronGeometry(0.2);
                this.material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            }
            explode(x, z, color, count=10, speed=1) {
                for(let i=0; i<count; i++) {
                    const mesh = new THREE.Mesh(this.geometry, this.material.clone());
                    mesh.material.color.setHex(color);
                    mesh.position.set(x, 0.5, z);
                    const angle = Math.random() * Math.PI * 2;
                    const velY = Math.random() * 0.2 * speed;
                    const velH = Math.random() * 0.3 * speed;
                    this.scene.add(mesh);
                    this.particles.push({ mesh, vx: Math.cos(angle)*velH, vy: velY, vz: Math.sin(angle)*velH, life: 1.0 });
                }
            }
            update(delta) {
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i];
                    p.life -= delta * 2;
                    if(p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1); continue;
                    }
                    p.mesh.position.x += p.vx; p.mesh.position.y += p.vy; p.mesh.position.z += p.vz;
                    p.mesh.rotation.x += delta*5; p.mesh.rotation.y += delta*5;
                    p.mesh.scale.setScalar(p.life);
                }
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020005);
            scene.fog = new THREE.FogExp2(0x050010, 0.012);

            camera = new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, 0.1, 500);
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
            composer.addPass(bloomPass);

            rgbShiftPass = new ShaderPass(RGBShiftShader);
            rgbShiftPass.uniforms['amount'].value = 0.001;
            composer.addPass(rgbShiftPass);

            const filmPass = new FilmPass(0.35, 0.25, 648, false);
            composer.addPass(filmPass);

            createEnvironment();
            snakeGroup = new THREE.Group(); scene.add(snakeGroup);
            particles = new ParticleSystem(scene);
            audioEngine = new AudioEngine();

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', startGame);

            // Touch
            const tLeft = document.getElementById('t-left');
            const tRight = document.getElementById('t-right');
            const tDash = document.getElementById('t-dash');
            tLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); queueInput('left'); });
            tRight.addEventListener('touchstart', (e)=>{ e.preventDefault(); queueInput('right'); });
            tDash.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(gameState.isPlaying) gameState.isDashing = true; });
            tDash.addEventListener('touchend', (e)=>{ e.preventDefault(); gameState.isDashing = false; });

            animate();
        }

        function createEnvironment() {
            const gridHelper = new THREE.GridHelper(GRID_SIZE*6, GRID_SIZE*3, 0x5500aa, 0x110022);
            gridHelper.position.y = -0.5; scene.add(gridHelper);
            const geo = new THREE.BoxGeometry(GRID_SIZE*2, 4, GRID_SIZE*2);
            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({ color: 0x00f3ff, linewidth: 2 });
            const walls = new THREE.LineSegments(edges, mat);
            walls.position.y = 1.5; scene.add(walls);

            cityGroup = new THREE.Group();
            for(let i=0; i<300; i++) {
                const angle = Math.random() * Math.PI*2;
                const dist = GRID_SIZE*1.5 + Math.random()*(GRID_SIZE*3.5);
                const x = Math.cos(angle)*dist; const z = Math.sin(angle)*dist;
                const h = 20 + Math.random()*60;
                const bGeo = new THREE.BoxGeometry(3, h, 3);
                const bEdges = new THREE.EdgesGeometry(bGeo);
                const color = Math.random() > 0.5 ? 0xaa00ff : 0x0066ff;
                const bMat = new THREE.LineBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
                const mesh = new THREE.LineSegments(bEdges, bMat);
                mesh.position.set(x, h/2 - 10, z); cityGroup.add(mesh);
            }
            scene.add(cityGroup);
            scene.add(new THREE.AmbientLight(0x404040, 0.8));
        }

        function startGame() {
            audioEngine.resume();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            gameState.isPlaying = true; gameState.score = 0; gameState.dashFuel = 0; gameState.isDashing = false;
            updateScoreUI(); updateDashUI();
            
            while(snakeGroup.children.length > 0) snakeGroup.remove(snakeGroup.children[0]);
            snakeData = [];
            for(let i=0; i<5; i++) addSnakePart(0, i);
            
            direction.set(0, 0, -1);
            
            // 입력 큐 초기화
            inputQueue = [];
            lastTurnAction = null;

            spawnFood();
            moveTimer = 0; lastTime = performance.now();
        }

        function addSnakePart(x, z) {
            const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const isHead = snakeData.length === 0;
            const mat = new THREE.MeshStandardMaterial({
                color: isHead ? 0xffffff : 0x00f3ff,
                emissive: isHead ? 0xffffff : 0x0044ff,
                emissiveIntensity: isHead ? 1.5 : 0.8,
                roughness: 0.2, metalness: 0.8
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0, z);
            snakeGroup.add(mesh);
            if(isHead) {
                const light = new THREE.PointLight(0x00f3ff, 5, 40);
                light.position.y = 2; mesh.add(light);
            }
            snakeData.push({ mesh, currX: x, currZ: z, prevX: x, prevZ: z });
        }

        function spawnFood() {
            if(foodMesh) scene.remove(foodMesh);
            let valid = false, x, z;
            while(!valid) {
                x = Math.floor(Math.random()*GRID_SIZE*2) - GRID_SIZE;
                z = Math.floor(Math.random()*GRID_SIZE*2) - GRID_SIZE;
                valid = true;
                for(let p of snakeData) if(Math.round(p.currX)===x && Math.round(p.currZ)===z) valid=false;
            }
            const geo = new THREE.OctahedronGeometry(0.6, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff5500, emissiveIntensity: 3.0 });
            foodMesh = new THREE.Mesh(geo, mat);
            foodMesh.position.set(x, 0.5, z);
            const light = new THREE.PointLight(0xff5500, 3, 10);
            foodMesh.add(light); scene.add(foodMesh);
            particles.explode(x, z, 0xffaa00, 5, 0.5);
        }

        // --- QUEUE BASED INPUT SYSTEM ---
        function queueInput(turnAction) {
            // 버퍼 제한 (너무 많이 쌓이면 반응 느려짐 방지)
            if(inputQueue.length < 2) {
                inputQueue.push(turnAction);
            }
        }

        function onKeyDown(e) {
            if(!gameState.isPlaying) return;
            
            if(e.key === 'ArrowLeft') {
                queueInput('left');
                lastTurnAction = 'left';
            }
            else if(e.key === 'ArrowRight') {
                queueInput('right');
                lastTurnAction = 'right';
            }
            else if(e.key === 'ArrowDown') {
                // 아래 화살표: 마지막 회전 반복 (U-Turn Macro)
                if(lastTurnAction) {
                    queueInput(lastTurnAction);
                }
            }
            else if(e.key === 'ArrowUp') {
                gameState.isDashing = true;
            }
        }

        function onKeyUp(e) {
            if(e.key === 'ArrowUp') gameState.isDashing = false;
        }

        function update(delta) {
            if(!gameState.isPlaying) {
                if(cityGroup) cityGroup.rotation.y += delta * 0.05;
                return;
            }

            let effectiveSpeed = BASE_SPEED;
            let isBoosting = false;
            if(gameState.isDashing && gameState.dashFuel > 0) {
                isBoosting = true;
                effectiveSpeed = BASE_SPEED / DASH_SPEED_MULT;
                gameState.dashFuel -= DASH_CONSUMPTION * delta;
                if(gameState.dashFuel < 0) gameState.dashFuel = 0;
                updateDashUI();
                rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(rgbShiftPass.uniforms['amount'].value, 0.005, 0.1);
                const tail = snakeData[snakeData.length-1];
                if(Math.random() > 0.5) particles.explode(tail.currX, tail.currZ, 0x00f3ff, 1, 0.5);
            } else {
                rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(rgbShiftPass.uniforms['amount'].value, 0.001, 0.1);
            }
            audioEngine.setDashState(isBoosting);

            moveTimer += delta;
            if(moveTimer >= effectiveSpeed) {
                moveTimer = 0;
                tick();
            }

            const progress = Math.min(moveTimer / effectiveSpeed, 1.0);
            for(let p of snakeData) {
                p.mesh.position.x = THREE.MathUtils.lerp(p.prevX, p.currX, progress);
                p.mesh.position.z = THREE.MathUtils.lerp(p.prevZ, p.currZ, progress);
            }
            updateCamera(progress, isBoosting);
            
            if(foodMesh) {
                foodMesh.rotation.y += delta * 4;
                foodMesh.position.y = 0.5 + Math.sin(performance.now()*0.008)*0.2;
            }
            particles.update(delta);
        }

        function tick() {
            // 큐에서 입력 하나 꺼내서 방향 적용
            if(inputQueue.length > 0) {
                const turnAction = inputQueue.shift();
                const axis = new THREE.Vector3(0, 1, 0);
                const angle = (turnAction === 'left') ? Math.PI/2 : -Math.PI/2;
                const newDir = direction.clone().applyAxisAngle(axis, angle);
                newDir.x = Math.round(newDir.x); newDir.z = Math.round(newDir.z);
                direction.copy(newDir);
            }

            const head = snakeData[0];
            const nx = head.currX + direction.x;
            const nz = head.currZ + direction.z;

            if(Math.abs(nx) > GRID_SIZE || Math.abs(nz) > GRID_SIZE) { gameOver(); return; }
            for(let i=0; i<snakeData.length-1; i++) {
                if(snakeData[i].currX === nx && snakeData[i].currZ === nz) { gameOver(); return; }
            }

            for(let p of snakeData) { p.prevX = p.currX; p.prevZ = p.currZ; }

            let ate = false;
            if(foodMesh && Math.round(nx) === Math.round(foodMesh.position.x) && Math.round(nz) === Math.round(foodMesh.position.z)) {
                ate = true;
                gameState.score += 10;
                audioEngine.score = gameState.score;
                audioEngine.playSound('eat');
                particles.explode(nx, nz, 0xffaa00, 20, 2);
                if(gameState.dashFuel < MAX_DASH_FUEL) {
                    gameState.dashFuel += 1.0;
                    if(gameState.dashFuel > MAX_DASH_FUEL) gameState.dashFuel = MAX_DASH_FUEL;
                    updateDashUI();
                }
                updateScoreUI(); spawnFood();
            }

            if(ate) {
                const tail = snakeData[snakeData.length-1];
                addSnakePart(tail.prevX, tail.prevZ);
                const newTail = snakeData[snakeData.length-1];
                newTail.prevX = tail.prevX; newTail.prevZ = tail.prevZ;
                newTail.currX = tail.prevX; newTail.currZ = tail.prevZ;
            }
            for(let i=snakeData.length-1; i>0; i--) {
                snakeData[i].currX = snakeData[i-1].currX;
                snakeData[i].currZ = snakeData[i-1].currZ;
            }
            head.currX = nx; head.currZ = nz;
        }

        function updateCamera(progress, isBoosting) {
            if(snakeData.length === 0) return;
            const head = snakeData[0].mesh;
            const backVec = direction.clone().negate().normalize();
            const targetDist = isBoosting ? 20 : 14;
            const targetHeight = isBoosting ? 8 : 10;
            const targetFOV = isBoosting ? 110 : 85;
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFOV, 0.05);
            camera.updateProjectionMatrix();
            const targetPos = new THREE.Vector3();
            targetPos.copy(head.position).add(backVec.multiplyScalar(targetDist)).add(new THREE.Vector3(0, targetHeight, 0));
            const lookPos = new THREE.Vector3();
            lookPos.copy(head.position).add(direction.clone().multiplyScalar(15));
            if(isBoosting) {
                targetPos.x += (Math.random()-0.5) * 0.2;
                targetPos.y += (Math.random()-0.5) * 0.2;
            }
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(lookPos);
        }

        function updateScoreUI() { document.getElementById('score').innerText = gameState.score; }
        function updateDashUI() {
            for(let i=0; i<4; i++) {
                const cell = document.getElementById(`cell-${i}`);
                if(gameState.dashFuel > i + 1) cell.style.width = '100%';
                else if (gameState.dashFuel > i) cell.style.width = `${(gameState.dashFuel - i) * 100}%`;
                else cell.style.width = '0%';
            }
        }
        function gameOver() {
            gameState.isPlaying = false; audioEngine.stop();
            snakeData.forEach(p => { p.mesh.visible = false; particles.explode(p.currX, p.currZ, 0xff0000, 5, 1); });
            rgbShiftPass.uniforms['amount'].value = 0.02;
            document.getElementById('final-score').innerText = gameState.score;
            document.getElementById('game-over-screen').style.display = 'block';
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;
            update(delta);
            composer.render();
        }

        init();
    </script>
</body>
</html>
