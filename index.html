<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake: Cyber City</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            color: #fff;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 10px #00f3ff;
            letter-spacing: 2px;
            display: flex;
            justify-content: space-between;
            z-index: 10;
        }
        
        .hud span { color: #00f3ff; }
        .audio-indicator { font-size: 14px; color: #555; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; color: #b000ff; } 100% { opacity: 0.5; } }

        .center-panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 0, 20, 0.85);
            border: 1px solid rgba(180, 0, 255, 0.5);
            padding: 50px 80px;
            pointer-events: auto;
            backdrop-filter: blur(12px);
            box-shadow: 0 0 100px rgba(132, 0, 255, 0.2), inset 0 0 30px rgba(100, 0, 255, 0.1);
            z-index: 50;
        }

        h1 {
            font-size: 64px;
            margin: 0 0 10px 0;
            font-weight: 800;
            font-style: italic;
            background: linear-gradient(90deg, #00f3ff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: -2px;
            text-shadow: 0 0 30px rgba(180, 0, 255, 0.5);
        }

        p { color: #aaddff; font-size: 18px; margin-bottom: 40px; letter-spacing: 1px;}

        .btn {
            background: rgba(180, 0, 255, 0.1);
            border: 2px solid #d500ff;
            color: #d500ff;
            padding: 15px 50px;
            font-size: 24px;
            font-family: inherit;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            box-shadow: 0 0 15px rgba(213, 0, 255, 0.2);
        }

        .btn:hover {
            background: #d500ff;
            color: #fff;
            box-shadow: 0 0 50px #d500ff;
            transform: scale(1.05);
        }

        #touch-area {
            display: none;
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: auto;
            z-index: 10;
        }
        .touch-zone { width: 50%; height: 100%; float: left; }

        @media (max-width: 768px) {
            #touch-area { display: block; }
            h1 { font-size: 40px; }
            .center-panel { width: 85%; padding: 30px; }
            .btn { font-size: 18px; padding: 12px 30px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud">
            <div>SCORE: <span id="score">0</span></div>
            <div class="audio-indicator">ğŸ”Š AUDIO ONLINE</div>
        </div>

        <div id="start-screen" class="center-panel">
            <h1>Neon City</h1>
            <p>
                HYPER SPEED // CITY LIGHTS<br>
                ì´ì–´í°ì„ ì°©ìš©í•˜ê³  ë„¤ì˜¨ ì‹œí‹°ë¥¼ ì§ˆì£¼í•˜ì‹­ì‹œì˜¤.
            </p>
            <button class="btn" id="btn-start">DRIVE</button>
        </div>

        <div id="game-over-screen" class="center-panel" style="display: none;">
            <h1 style="background: linear-gradient(90deg, #ff0055, #ff9900); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">CRASHED</h1>
            <p>DATA RECOVERED: <span id="final-score" style="color:#fff">0</span></p>
            <button class="btn" id="btn-restart" style="border-color: #ff0055; color: #ff0055;">RETRY</button>
        </div>

        <div id="touch-area">
            <div class="touch-zone" id="t-left"></div>
            <div class="touch-zone" id="t-right"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- ì‚¬ìš´ë“œ ì—”ì§„ (Synthwave City Edition) ---
        class CyberSynth {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(this.ctx.destination);
                
                this.isPlaying = false;
                this.nextNoteTime = 0;
                this.tempo = 125; // ì•½ê°„ ë” ë¹ ë¥´ê²Œ
                this.beatCount = 0;

                // ë©œë¡œë”” íŒ¨í„´ (Pentatonic-ish)
                // 0: ì‰¼í‘œ, ìˆ«ì: ì£¼íŒŒìˆ˜ ë°°ìˆ˜ í˜¹ì€ íŠ¹ì • ë…¸íŠ¸ ì¸ë±ìŠ¤
                // ì—¬ê¸°ì„  ê°„ë‹¨íˆ ì£¼íŒŒìˆ˜ ë°°ì—´ë¡œ ì²˜ë¦¬
                // A Minor scale high pitch sequence
                const root = 880; // High A
                // A, C, D, E, G
                this.melodyNotes = [
                    880, 0, 1046, 0, 1174, 1318, 0, 1046,
                    1567, 0, 1318, 0, 1174, 0, 1046, 1174,
                    880, 880, 0, 1046, 0, 1318, 1174, 0,
                    1760, 1567, 1318, 1174, 1046, 1174, 1318, 1567
                ];
            }

            resume() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime;
                // ë§ˆìŠ¤í„° ë³¼ë¥¨ ë¦¬ì…‹ (ì£½ì—ˆë‹¤ ì‚´ì•„ë‚  ë•Œë¥¼ ìœ„í•´)
                this.masterGain.gain.cancelScheduledValues(this.ctx.currentTime);
                this.masterGain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                this.scheduler();
            }

            stopAndFade() {
                this.isPlaying = false;
                // 2ì´ˆ ë™ì•ˆ í˜ì´ë“œ ì•„ì›ƒ
                const t = this.ctx.currentTime;
                this.masterGain.gain.cancelScheduledValues(t);
                this.masterGain.gain.setValueAtTime(this.masterGain.gain.value, t);
                this.masterGain.gain.linearRampToValueAtTime(0, t + 2.0);
            }

            scheduler() {
                if(!this.isPlaying) return;
                const secondsPerBeat = 60.0 / this.tempo;
                const lookahead = 0.1; 

                while (this.nextNoteTime < this.ctx.currentTime + lookahead) {
                    this.playBeat(this.nextNoteTime, this.beatCount);
                    this.nextNoteTime += secondsPerBeat / 4; // 16ë¶„ ìŒí‘œ ë‹¨ìœ„
                    this.beatCount++;
                }
                setTimeout(() => this.scheduler(), 25);
            }

            playBeat(time, beat) {
                const step16 = beat % 16;
                const step4 = Math.floor(beat / 4) % 4; // 4ë¶„ìŒí‘œ ê¸°ì¤€

                // 1. KICK (ì¿µ) - ì •ë°•
                if (step16 % 4 === 0) {
                    this.playKick(time);
                    this.playBass(time, step16 === 0 ? 55 : (step16 === 8 ? 65 : 55));
                }
                
                // 2. SNARE (ì°©)
                if (step16 === 4 || step16 === 12) {
                    this.playSnare(time);
                }

                // 3. HI-HAT (ì¹˜ì¹«) - 16ë¹„íŠ¸ ìª¼ê°œê¸°
                if (step16 % 2 === 0) {
                   this.playHiHat(time, step16 % 4 === 2 ? 0.08 : 0.04);
                }

                // 4. MAIN MELODY (ë ë¦¬ë¦¬ë§)
                // 32ìŠ¤í… íŒ¨í„´ ë°˜ë³µ
                const melodyStep = beat % 32;
                const note = this.melodyNotes[melodyStep];
                if (note > 0) {
                    this.playLead(time, note);
                }
            }

            playLead(time, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = 'square'; // ë ˆíŠ¸ë¡œ ê²Œì„ ëŠë‚Œ
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.Q.value = 5; // ì•½ê°„ì˜ ì‡³ì†Œë¦¬(Resonance)

                const gain = this.ctx.createGain();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.frequency.setValueAtTime(freq, time);
                
                // í•„í„° ìŠ¤ìœ• (Wah íš¨ê³¼)
                filter.frequency.setValueAtTime(freq * 2, time);
                filter.frequency.exponentialRampToValueAtTime(freq, time + 0.1);

                gain.gain.setValueAtTime(0.1, time); // ë³¼ë¥¨ì€ ì‘ê²Œ (ë°°ê²½ìŒê³¼ ì„ì´ê²Œ)
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.15);

                osc.start(time);
                osc.stop(time + 0.15);
            }

            playKick(time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(0.8, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time); osc.stop(time + 0.5);
            }

            playSnare(time) {
                const bufferSize = this.ctx.sampleRate * 0.2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 800;
                const gain = this.ctx.createGain();
                noise.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time);
            }

            playHiHat(time, vol) {
                const bufferSize = this.ctx.sampleRate * 0.05;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass'; filter.frequency.value = 6000;
                const gain = this.ctx.createGain();
                noise.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                noise.start(time);
            }

            playBass(time, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                const gain = this.ctx.createGain();
                osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(freq, time);
                filter.frequency.setValueAtTime(100, time);
                filter.frequency.exponentialRampToValueAtTime(600, time + 0.05);
                filter.frequency.exponentialRampToValueAtTime(100, time + 0.2);
                gain.gain.setValueAtTime(0.4, time);
                gain.gain.linearRampToValueAtTime(0, time + 0.3);
                osc.start(time); osc.stop(time + 0.3);
            }

            playEatEffect() {
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.masterGain);
                osc.frequency.setValueAtTime(1200, t);
                osc.frequency.linearRampToValueAtTime(2000, t + 0.1);
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                osc.start(t); osc.stop(t + 0.1);
            }
        }


        // --- ê²Œì„ ì„¤ì • ---
        const GRID_SIZE = 30; 
        const SPEED_BASE = 0.07; // Very fast
        
        let currentSpeed = SPEED_BASE;
        let scene, camera, renderer, composer;
        let snakeGroup, foodMesh, cityGroup;
        let snakeData = []; 
        let direction = new THREE.Vector3(0, 0, -1);
        let nextDirection = new THREE.Vector3(0, 0, -1);
        
        let lastTime = 0;
        let moveTimer = 0;
        let isPlaying = false;
        let score = 0;
        let soundEngine;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020005);
            // ì§™ì€ ë³´ë¼ìƒ‰ ì•ˆê°œë¡œ ë„ì‹œì™€ ë°”ë‹¥ì„ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°
            scene.fog = new THREE.FogExp2(0x050010, 0.015);

            // Wide FOV
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 300);
            
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Bloom Effect (Cyberpunk Glow)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 1.8;
            bloomPass.radius = 0.5;
            bloomPass.threshold = 0.1;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0x404040, 0.6));
            
            createArena();
            createCity(); // ë„ì‹œ ìƒì„±

            snakeGroup = new THREE.Group();
            scene.add(snakeGroup);

            soundEngine = new CyberSynth();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            
            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', startGame);
            
            const tLeft = document.getElementById('t-left');
            const tRight = document.getElementById('t-right');
            const handleTouch = (dir) => { if(isPlaying) turn(dir); };
            tLeft.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('left'); });
            tRight.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('right'); });

            animate();
        }

        function createArena() {
            // ë¬´í•œí•œ ëŠë‚Œì˜ ë°”ë‹¥
            const gridHelper = new THREE.GridHelper(GRID_SIZE * 6, GRID_SIZE * 3, 0x8800ff, 0x110022);
            gridHelper.position.y = -0.5;
            scene.add(gridHelper);

            // ê²½ê³„ì„  (ë°ì€ ì²­ë¡ìƒ‰)
            const geometry = new THREE.BoxGeometry(GRID_SIZE * 2, 2, GRID_SIZE * 2);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ color: 0x00f3ff, linewidth: 2 });
            const walls = new THREE.LineSegments(edges, material);
            walls.position.y = 0.5;
            scene.add(walls);
        }

        function createCity() {
            cityGroup = new THREE.Group();
            const buildingCount = 200;
            const minDist = GRID_SIZE * 1.5; // ê²Œì„ ë§µë³´ë‹¤ ë©€ë¦¬
            const maxDist = GRID_SIZE * 4;

            for(let i=0; i<buildingCount; i++) {
                // ëœë¤ ìœ„ì¹˜ (ë„ë„› ëª¨ì–‘ ë¶„í¬)
                const angle = Math.random() * Math.PI * 2;
                const dist = minDist + Math.random() * (maxDist - minDist);
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                
                // ëœë¤ ë†’ì´ì™€ ë‘ê»˜
                const h = 10 + Math.random() * 40;
                const w = 2 + Math.random() * 4;
                const d = 2 + Math.random() * 4;

                // ë¹Œë”© ë³¸ì²´ (ê²€ì€ìƒ‰)
                const geometry = new THREE.BoxGeometry(w, h, d);
                // ë„¤ì˜¨ ì—£ì§€ (ë³´ë¼ìƒ‰ ë˜ëŠ” íŒŒë€ìƒ‰ ëœë¤)
                const edges = new THREE.EdgesGeometry(geometry);
                const color = Math.random() > 0.5 ? 0xaa00ff : 0x0088ff; // Purple or Blue
                const material = new THREE.LineBasicMaterial({ color: color });
                
                const building = new THREE.LineSegments(edges, material);
                building.position.set(x, h/2 - 5, z); // ì•½ê°„ ì•„ë˜ë¡œ ë‚´ë ¤ì„œ ë°”ë‹¥ì— ë¬»íˆê²Œ
                
                // ê°€ë” ì°½ë¬¸ì²˜ëŸ¼ ë¹›ë‚˜ëŠ” ë°•ìŠ¤ ì¶”ê°€
                if(Math.random() > 0.7) {
                    const winGeo = new THREE.BoxGeometry(w*0.8, h*0.8, d*0.8);
                    const winMat = new THREE.MeshBasicMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.1 
                    });
                    const winMesh = new THREE.Mesh(winGeo, winMat);
                    building.add(winMesh);
                }

                cityGroup.add(building);
            }
            scene.add(cityGroup);
        }

        function startGame() {
            soundEngine.resume();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';

            score = 0;
            updateUI();
            currentSpeed = SPEED_BASE;
            
            while(snakeGroup.children.length > 0) snakeGroup.remove(snakeGroup.children[0]);
            snakeData = [];
            
            // ì‹œì‘ ê¸¸ì´
            for(let i=0; i<6; i++) addSnakePart(0, i);

            direction.set(0, 0, -1);
            nextDirection.copy(direction);

            moveTimer = 0;
            lastTime = performance.now();
            
            spawnFood();
            isPlaying = true;
        }

        function addSnakePart(x, z) {
            const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const isHead = snakeData.length === 0;
            const material = new THREE.MeshStandardMaterial({
                color: isHead ? 0xffffff : 0x00f3ff,
                emissive: isHead ? 0xffffff : 0x0044ff,
                emissiveIntensity: isHead ? 1.0 : 0.5,
                roughness: 0.1, metalness: 0.8
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0, z);
            snakeGroup.add(mesh);
            
            if (isHead) {
                const light = new THREE.PointLight(0x00f3ff, 4, 30); 
                light.position.y = 2;
                mesh.add(light);
            }
            snakeData.push({ mesh, currX: x, currZ: z, prevX: x, prevZ: z });
        }

        function spawnFood() {
            if (foodMesh) scene.remove(foodMesh);
            let valid = false, x, z;
            while(!valid) {
                x = Math.floor(Math.random() * (GRID_SIZE * 2)) - GRID_SIZE;
                z = Math.floor(Math.random() * (GRID_SIZE * 2)) - GRID_SIZE;
                valid = true;
                for(let p of snakeData) if(Math.round(p.currX) === x && Math.round(p.currZ) === z) valid = false;
            }

            const geometry = new THREE.OctahedronGeometry(0.6, 0);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 2.0
            });
            foodMesh = new THREE.Mesh(geometry, material);
            foodMesh.position.set(x, 0.5, z);
            
            const light = new THREE.PointLight(0xff00ff, 2, 5);
            foodMesh.add(light);
            
            scene.add(foodMesh);
        }

        function turn(side) {
            const axis = new THREE.Vector3(0, 1, 0);
            const angle = (side === 'left') ? Math.PI / 2 : -Math.PI / 2;
            const newDir = direction.clone().applyAxisAngle(axis, angle);
            newDir.x = Math.round(newDir.x); newDir.z = Math.round(newDir.z);
            nextDirection.copy(newDir);
        }

        function onKeyDown(e) {
            if (!isPlaying) return;
            if (e.key === 'ArrowLeft') turn('left');
            if (e.key === 'ArrowRight') turn('right');
        }

        function update(delta) {
            if (!isPlaying) {
                // ê²Œì„ ì˜¤ë²„ ìƒíƒœì—ì„œë„ ë„ì‹œëŠ” ì²œì²œíˆ íšŒì „
                if(cityGroup) cityGroup.rotation.y += delta * 0.05;
                return;
            }
            
            moveTimer += delta;
            
            if (moveTimer >= currentSpeed) {
                moveTimer = 0;
                tick();
            }

            const progress = Math.min(moveTimer / currentSpeed, 1.0);
            for (let part of snakeData) {
                part.mesh.position.x = THREE.MathUtils.lerp(part.prevX, part.currX, progress);
                part.mesh.position.z = THREE.MathUtils.lerp(part.prevZ, part.currZ, progress);
            }
            updateCamera(progress);

            if(foodMesh) {
                foodMesh.rotation.y += delta * 4;
                foodMesh.position.y = 0.5 + Math.sin(performance.now() * 0.008) * 0.2;
            }
        }

        function tick() {
            direction.copy(nextDirection);
            const head = snakeData[0];
            const nextX = head.currX + direction.x;
            const nextZ = head.currZ + direction.z;

            if (Math.abs(nextX) > GRID_SIZE || Math.abs(nextZ) > GRID_SIZE) { gameOver(); return; }
            for (let i = 0; i < snakeData.length - 1; i++) {
                if (snakeData[i].currX === nextX && snakeData[i].currZ === nextZ) { gameOver(); return; }
            }

            for (let part of snakeData) { part.prevX = part.currX; part.prevZ = part.currZ; }

            let ate = false;
            if (foodMesh && Math.round(nextX) === Math.round(foodMesh.position.x) && Math.round(nextZ) === Math.round(foodMesh.position.z)) {
                ate = true;
                score += 10;
                updateUI();
                soundEngine.playEatEffect();
                spawnFood();
                currentSpeed = Math.max(0.035, currentSpeed * 0.99); 
            }

            if (ate) {
                const tail = snakeData[snakeData.length - 1];
                addSnakePart(tail.prevX, tail.prevZ);
                const newTail = snakeData[snakeData.length - 1];
                newTail.prevX = tail.prevX; newTail.prevZ = tail.prevZ;
                newTail.currX = tail.prevX; newTail.currZ = tail.prevZ;
            }

            for (let i = snakeData.length - 1; i > 0; i--) {
                snakeData[i].currX = snakeData[i - 1].currX;
                snakeData[i].currZ = snakeData[i - 1].currZ;
            }
            head.currX = nextX; head.currZ = nextZ;
        }

        function updateCamera(progress) {
            if (snakeData.length === 0) return;
            const head = snakeData[0].mesh;
            
            // ì¹´ë©”ë¼ê°€ ë±€ì„ ë” ë‹¤ì´ë‚´ë¯¹í•˜ê²Œ ë”°ë¼ê°
            const backVec = direction.clone().negate().normalize();
            const targetPos = new THREE.Vector3();
            // Distance 14, Height 10
            targetPos.copy(head.position).add(backVec.multiplyScalar(14)).add(new THREE.Vector3(0, 10, 0));
            
            const lookPos = new THREE.Vector3();
            lookPos.copy(head.position).add(direction.clone().multiplyScalar(12));

            camera.position.lerp(targetPos, 0.1); // ë¶€ë“œëŸ¬ì›€ ì¡°ì ˆ
            camera.lookAt(lookPos);
        }

        function gameOver() {
            isPlaying = false;
            soundEngine.stopAndFade(); // ìŒì•… í˜ì´ë“œ ì•„ì›ƒ

            // ë±€ ìƒ‰ê¹” ë¶‰ê²Œ ë³€í•¨
            snakeData.forEach(p => {
                p.mesh.material.color.setHex(0xff0000);
                p.mesh.material.emissive.setHex(0xff0000);
            });

            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'block';
        }

        function updateUI() { document.getElementById('score').innerText = score; }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;
            update(delta);
            composer.render();
        }

        init();
    </script>
</body>
</html>
