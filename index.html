<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SNAKE: HYBRID</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        #adrenaline-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.2) 90%);
            box-shadow: inset 0 0 100px #000;
            opacity: 0; transition: opacity 0.2s; pointer-events: none;
            z-index: 5; mix-blend-mode: overlay;
        }

        .hud-top {
            padding: 30px; display: flex; justify-content: space-between; align-items: flex-start;
        }
        .score-container { text-align: left; }
        .score-label { font-size: 16px; color: var(--theme-color, #00f3ff); opacity: 0.7; letter-spacing: 2px; transition: color 1s;}
        .score-value { font-size: 48px; font-weight: 800; color: #fff; text-shadow: 0 0 20px var(--theme-color, #00f3ff); line-height: 1; transition: text-shadow 1s;}

        .phase-indicator {
            font-size: 14px; font-weight: bold; color: #fff; background: rgba(255,255,255,0.1);
            padding: 4px 10px; border-radius: 4px; margin-top: 5px; opacity: 0.8;
        }

        .hud-bottom {
            padding: 30px; display: flex; flex-direction: column; align-items: center; gap: 10px;
        }
        .nitro-label { color: #ffcc00; font-size: 14px; letter-spacing: 4px; font-weight: 700; text-shadow: 0 0 10px #ffcc00; }
        .nitro-bar-container { display: flex; gap: 8px; }
        .nitro-cell { width: 60px; height: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 204, 0, 0.3); transform: skewX(-20deg); position: relative; overflow: hidden; }
        .nitro-fill { position: absolute; top: 0; left: 0; bottom: 0; width: 0%; background: #ffcc00; box-shadow: 0 0 15px #ffcc00; transition: width 0.1s linear; }

        .center-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(5, 5, 10, 0.9); border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 50px 80px; pointer-events: auto;
            backdrop-filter: blur(20px);
            box-shadow: 0 0 100px rgba(0,0,0, 0.5), inset 0 0 50px rgba(0, 0, 0, 0.8);
            z-index: 50;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }

        h1 {
            font-size: 72px; margin: 0; font-weight: 800; font-style: italic;
            background: linear-gradient(135deg, #fff 0%, #00f3ff 50%, #ff00ff 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 50px rgba(0, 243, 255, 0.5); letter-spacing: -3px; line-height: 0.9;
        }
        p { color: #8899a6; font-size: 18px; margin: 20px 0 40px 0; letter-spacing: 1px; }

        .key-hint {
            display: inline-block; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
            padding: 2px 8px; border-radius: 4px; color: #fff; font-weight: bold; font-size: 0.9em; margin: 0 2px;
        }

        .btn {
            background: transparent; border: 2px solid #fff; color: #fff;
            padding: 18px 60px; font-size: 24px; font-family: inherit; font-weight: 800;
            cursor: pointer; text-transform: uppercase; letter-spacing: 4px; transition: 0.2s;
            position: relative; overflow: hidden;
        }
        .btn:hover { background: #fff; color: #000; box-shadow: 0 0 60px rgba(255,255,255,0.8); }

        #scanline {
            position: fixed; left: 0; top: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.1) 50%, rgba(0,0,0,0.1));
            background-size: 100% 4px; pointer-events: none; z-index: 99; opacity: 0.5;
        }

        #mobile-controls { display: none; position: absolute; bottom: 0; width: 100%; height: 100%; z-index: 20; }
        .touch-left, .touch-right { width: 50%; height: 100%; float: left; }
        .touch-dash { 
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            width: 100px; height: 100px; border-radius: 50%; border: 2px solid #ffcc00;
            background: rgba(255, 204, 0, 0.1); pointer-events: auto;
            display: flex; align-items: center; justify-content: center; color: #ffcc00; font-weight: bold;
        }

        @media (max-width: 768px) {
            #mobile-controls { display: block; }
            h1 { font-size: 48px; }
            .center-panel { width: 85%; padding: 40px; }
            .hud-top { padding: 20px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="scanline"></div>
    <div id="adrenaline-overlay"></div>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score-container">
                <div class="score-label">SYNC RATE</div>
                <div class="score-value" id="score">0</div>
                <div class="phase-indicator" id="phase-label">PHASE 1: STABLE</div>
            </div>
        </div>

        <div id="start-screen" class="center-panel">
            <h1>NEON<br>HYBRID</h1>
            <p>
                <span class="key-hint">←</span> <span class="key-hint">→</span> TURN <span style="color:#aaa">|</span> 
                <span class="key-hint">↓</span> REPEAT TURN<br><br>
                <span class="key-hint" style="color:#ffcc00; border-color:#ffcc00">↑ HOLD</span> HYPER DASH<br>
                <span class="key-hint" style="color:#00ff00; border-color:#00ff00">TARGET</span> TURNS GREEN ON ALIGN
            </p>
            <button class="btn" id="btn-start">JACK IN</button>
        </div>

        <div id="game-over-screen" class="center-panel" style="display: none;">
            <h1 style="background: linear-gradient(90deg, #ff0055, #ff4400); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">FLATLINED</h1>
            <p>FINAL SYNC: <span id="final-score" style="color:#fff; font-weight:bold;">0</span></p>
            <button class="btn" id="btn-restart" style="border-color: #ff0055; color: #ff0055;">REBOOT</button>
        </div>

        <div class="hud-bottom">
            <div class="nitro-label">HYPER CHARGE</div>
            <div class="nitro-bar-container">
                <div class="nitro-cell"><div class="nitro-fill" id="cell-0"></div></div>
                <div class="nitro-cell"><div class="nitro-fill" id="cell-1"></div></div>
                <div class="nitro-cell"><div class="nitro-fill" id="cell-2"></div></div>
                <div class="nitro-cell"><div class="nitro-fill" id="cell-3"></div></div>
            </div>
        </div>

        <div id="mobile-controls">
            <div class="touch-left" id="t-left"></div>
            <div class="touch-right" id="t-right"></div>
            <div class="touch-dash" id="t-dash">DASH</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.adrenalineFilter = this.ctx.createBiquadFilter();
                this.adrenalineFilter.type = 'lowpass';
                this.adrenalineFilter.frequency.value = 22000;
                this.adrenalineFilter.Q.value = 1;
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.5;
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.connect(this.adrenalineFilter);
                this.adrenalineFilter.connect(this.ctx.destination);
                this.reverb = this.createReverb(2.0);
                this.reverbGain = this.ctx.createGain();
                this.reverbGain.gain.value = 0.3;
                this.master.connect(this.compressor);
                this.master.connect(this.reverb);
                this.reverb.connect(this.reverbGain);
                this.reverbGain.connect(this.adrenalineFilter);
                this.isPlaying = false;
                this.tempo = 128;
                this.nextNoteTime = 0;
                this.beat = 0;
                this.dashIntensity = 0;
                this.phase = 1;
            }
            createReverb(duration) {
                const len = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for(let c=0; c<2; c++) {
                    const d = buffer.getChannelData(c);
                    for(let i=0; i<len; i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/len, 2);
                }
                const conv = this.ctx.createConvolver();
                conv.buffer = buffer;
                return conv;
            }
            resume() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                
                // [FIX] 리스타트 시 볼륨 복구 코드 추가
                this.master.gain.cancelScheduledValues(this.ctx.currentTime);
                this.master.gain.setValueAtTime(0.5, this.ctx.currentTime);
                
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.schedule();
            }
            stop() {
                this.isPlaying = false;
                // 여기서 볼륨을 0으로 줄였기 때문에 resume에서 복구해야 함
                this.master.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
            }
            setDashState(isDashing) {
                this.dashIntensity = isDashing ? 1 : 0;
            }
            setAdrenaline(active) {
                const now = this.ctx.currentTime;
                const targetFreq = active ? 400 : 22000;
                this.adrenalineFilter.frequency.setTargetAtTime(targetFreq, now, 0.2);
            }
            schedule() {
                if(!this.isPlaying) return;
                const secPerBeat = 60.0 / this.tempo;
                const lookahead = 0.1;
                while(this.nextNoteTime < this.ctx.currentTime + lookahead) {
                    this.playTick(this.nextNoteTime, this.beat);
                    this.nextNoteTime += secPerBeat / 4;
                    this.beat++;
                }
                setTimeout(() => this.schedule(), 25);
            }
            playTick(t, beat) {
                const step16 = beat % 16;
                if(step16 % 4 === 0) this.synthKick(t);
                if(step16 % 4 === 2 || step16 % 4 === 3) {
                    const freq = this.dashIntensity ? 110 : (this.phase === 3 ? 65 : 55); 
                    this.synthBass(t, freq);
                }
                if(this.phase >= 2) {
                    if(step16 === 4 || step16 === 12) this.synthSnare(t);
                }
                if(step16 % 2 === 0) {
                    if(this.dashIntensity || this.phase >= 2) this.synthHihat(t, step16 % 4 === 2 ? 0.1 : 0.05);
                    else if(step16 % 4 === 2) this.synthHihat(t, 0.05);
                }
                const scale = [0, 3, 5, 7, 10]; 
                const root = 440; 
                const noteIdx = (beat * (this.phase === 3 ? 7 : 3)) % 5;
                const octave = (this.dashIntensity || this.phase === 3) ? 2 : 1; 
                if(step16 % 2 === 0) {
                    const freq = root * Math.pow(2, scale[noteIdx]/12 - 1) * octave;
                    this.synthArp(t, freq, this.dashIntensity ? 0.15 : 0.05);
                }
            }
            synthKick(t){ const o=this.ctx.createOscillator();const g=this.ctx.createGain();o.connect(g);g.connect(this.master);o.frequency.setValueAtTime(150,t);o.frequency.exponentialRampToValueAtTime(0.01,t+0.5);g.gain.setValueAtTime(1,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.5);o.start(t);o.stop(t+0.5); }
            synthBass(t,f){ const o=this.ctx.createOscillator();o.type='sawtooth';const fl=this.ctx.createBiquadFilter();fl.type='lowpass';const g=this.ctx.createGain();o.connect(fl);fl.connect(g);g.connect(this.master);o.frequency.setValueAtTime(f,t);const q=this.dashIntensity?2000:400;fl.frequency.setValueAtTime(100,t);fl.frequency.exponentialRampToValueAtTime(q,t+0.1);g.gain.setValueAtTime(0.4,t);g.gain.linearRampToValueAtTime(0,t+0.2);o.start(t);o.stop(t+0.2); }
            synthSnare(t){ const b=this.ctx.createBuffer(1,this.ctx.sampleRate*0.2,this.ctx.sampleRate);const d=b.getChannelData(0);for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;const s=this.ctx.createBufferSource();s.buffer=b;const f=this.ctx.createBiquadFilter();f.type='highpass';f.frequency.value=1000;const g=this.ctx.createGain();s.connect(f);f.connect(g);g.connect(this.master);g.connect(this.reverb);g.gain.setValueAtTime(0.5,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.2);s.start(t); }
            synthHihat(t,v){ const o=this.ctx.createOscillator();o.type='square';const f=this.ctx.createBiquadFilter();f.type='highpass';f.frequency.value=8000;const g=this.ctx.createGain();o.connect(f);f.connect(g);g.connect(this.master);o.frequency.setValueAtTime(800+Math.random()*200,t);g.gain.setValueAtTime(v,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.05);o.start(t);o.stop(t+0.05); }
            synthArp(t,f,v){ const o=this.ctx.createOscillator();o.type='triangle';const g=this.ctx.createGain();const d=this.ctx.createDelay();d.delayTime.value=0.25;const dg=this.ctx.createGain();dg.gain.value=0.4;o.connect(g);g.connect(this.master);g.connect(d);d.connect(dg);dg.connect(this.master);dg.connect(d);o.frequency.setValueAtTime(f,t);g.gain.setValueAtTime(v,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.3);o.start(t);o.stop(t+0.5); }
            playSound(type){ const t=this.ctx.currentTime; if(type==='eat'){ const o=this.ctx.createOscillator();o.type='sine';o.frequency.setValueAtTime(1000,t);o.frequency.linearRampToValueAtTime(2000,t+0.1);const g=this.ctx.createGain();g.gain.setValueAtTime(0.5,t);g.gain.exponentialRampToValueAtTime(0.01,t+0.1);o.connect(g);g.connect(this.master);o.start(t);o.stop(t+0.1); } }
        }

        // --- PHASE MANAGER ---
        const PHASES = [
            { score: 0, color: 0x00f3ff, name: "PHASE 1: STABLE", fog: 0x050010 },
            { score: 50, color: 0xbc13fe, name: "PHASE 2: ACCEL", fog: 0x1a0022 },
            { score: 150, color: 0xff0044, name: "PHASE 3: CRITICAL", fog: 0x220000 }
        ];

        // --- GAME CONSTANTS ---
        const GRID_SIZE = 40;
        const BASE_SPEED = 0.08;
        const DASH_SPEED_MULT = 2.5;
        const MAX_DASH_FUEL = 4.0;
        const DASH_CONSUMPTION = 0.5;
        const ADRENALINE_RANGE = 3; 
        const FOOD_COUNT = 2;
        
        let scene, camera, renderer, composer, rgbShiftPass, filmPass;
        let snakeGroup, cityGroup, particles, gridHelper, wallLines;
        let snakeData = [];
        let direction = new THREE.Vector3(0, 0, -1);
        let inputQueue = [], lastTurnAction = null;
        let foodMeshes = [];
        let gameState = { isPlaying: false, score: 0, speed: BASE_SPEED, dashFuel: 0, isDashing: false, phase: 0 };
        let lastTime = 0, moveTimer = 0, audioEngine;
        let currentThemeColor = new THREE.Color(PHASES[0].color);
        let targetThemeColor = new THREE.Color(PHASES[0].color);
        let adrenalineFactor = 1.0;

        // Particle System
        class ParticleSystem {
            constructor(scene) {
                this.particles = []; this.scene = scene; this.geometry = new THREE.TetrahedronGeometry(0.2); this.material = new THREE.MeshBasicMaterial({ color: 0xffffff });
            }
            explode(x, z, color, count=10, speed=1) {
                for(let i=0; i<count; i++) {
                    const mesh = new THREE.Mesh(this.geometry, this.material.clone());
                    mesh.material.color.setHex(color); mesh.position.set(x, 0.5, z);
                    const angle = Math.random()*Math.PI*2; const velY = Math.random()*0.2*speed; const velH = Math.random()*0.3*speed;
                    this.scene.add(mesh); this.particles.push({ mesh, vx: Math.cos(angle)*velH, vy: velY, vz: Math.sin(angle)*velH, life: 1.0 });
                }
            }
            update(delta) {
                for(let i=this.particles.length-1; i>=0; i--) {
                    const p = this.particles[i]; p.life -= delta*2;
                    if(p.life <= 0) { this.scene.remove(p.mesh); this.particles.splice(i, 1); continue; }
                    p.mesh.position.x += p.vx; p.mesh.position.y += p.vy; p.mesh.position.z += p.vz;
                    p.mesh.rotation.x += delta*5; p.mesh.rotation.y += delta*5; p.mesh.scale.setScalar(p.life);
                }
            }
        }

        function init() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x020005); scene.fog = new THREE.FogExp2(0x050010, 0.012);
            camera = new THREE.PerspectiveCamera(85, window.innerWidth/window.innerHeight, 0.1, 500);
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            
            // [HYBRID GRAPHICS] Revert Bloom to High Quality (visible walls)
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; // Restored low threshold for wall visibility
            bloomPass.strength = 1.5;  // Restored strength for glorious glow
            bloomPass.radius = 0.5;
            composer.addPass(bloomPass);

            rgbShiftPass = new ShaderPass(RGBShiftShader); rgbShiftPass.uniforms['amount'].value = 0.001; composer.addPass(rgbShiftPass);
            filmPass = new FilmPass(0.35, 0.25, 648, false); composer.addPass(filmPass);

            createEnvironment();
            snakeGroup = new THREE.Group(); scene.add(snakeGroup);
            particles = new ParticleSystem(scene);
            audioEngine = new AudioEngine();

            window.addEventListener('resize', onResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', startGame);

            const tLeft = document.getElementById('t-left'); const tRight = document.getElementById('t-right'); const tDash = document.getElementById('t-dash');
            tLeft.addEventListener('touchstart', (e)=>{ e.preventDefault(); queueInput('left'); });
            tRight.addEventListener('touchstart', (e)=>{ e.preventDefault(); queueInput('right'); });
            tDash.addEventListener('touchstart', (e)=>{ e.preventDefault(); if(gameState.isPlaying) gameState.isDashing = true; });
            tDash.addEventListener('touchend', (e)=>{ e.preventDefault(); gameState.isDashing = false; });

            animate();
        }

        function createEnvironment() {
            gridHelper = new THREE.GridHelper(GRID_SIZE*6, GRID_SIZE*3, 0x5500aa, 0x110022);
            gridHelper.position.y = -0.5; scene.add(gridHelper);
            const geo = new THREE.BoxGeometry(GRID_SIZE*2, 4, GRID_SIZE*2);
            const edges = new THREE.EdgesGeometry(geo);
            const mat = new THREE.LineBasicMaterial({ color: 0x00f3ff, linewidth: 2 });
            wallLines = new THREE.LineSegments(edges, mat);
            wallLines.position.y = 1.5; scene.add(wallLines);

            cityGroup = new THREE.Group();
            for(let i=0; i<300; i++) {
                const angle = Math.random()*Math.PI*2; const dist = GRID_SIZE*1.5 + Math.random()*(GRID_SIZE*3.5);
                const x = Math.cos(angle)*dist; const z = Math.sin(angle)*dist;
                const h = 20 + Math.random()*60;
                const bGeo = new THREE.BoxGeometry(3, h, 3); const bEdges = new THREE.EdgesGeometry(bGeo);
                const bMat = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.5 }); // Increased visibility
                const mesh = new THREE.LineSegments(bEdges, bMat);
                mesh.position.set(x, h/2 - 10, z); cityGroup.add(mesh);
            }
            scene.add(cityGroup);
            scene.add(new THREE.AmbientLight(0x404040, 0.8));
        }

        function startGame() {
            audioEngine.resume();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            gameState.isPlaying = true; gameState.score = 0; gameState.dashFuel = 0; gameState.isDashing = false; gameState.phase = 0;
            updatePhase(0); updateScoreUI(); updateDashUI();
            
            while(snakeGroup.children.length > 0) snakeGroup.remove(snakeGroup.children[0]);
            snakeData = [];
            for(let i=0; i<5; i++) addSnakePart(0, i);
            direction.set(0, 0, -1); inputQueue = []; lastTurnAction = null;
            
            foodMeshes.forEach(m => scene.remove(m));
            foodMeshes = [];
            for(let i=0; i<FOOD_COUNT; i++) spawnFood();

            moveTimer = 0; lastTime = performance.now();
        }

        function addSnakePart(x, z) {
            const geo = new THREE.BoxGeometry(0.85, 0.85, 0.85); // Keep small size for precision
            const isHead = snakeData.length === 0;
            const mat = new THREE.MeshStandardMaterial({
                color: isHead ? 0xffffff : currentThemeColor,
                emissive: isHead ? 0xffffff : currentThemeColor,
                emissiveIntensity: isHead ? 1.0 : 0.5, 
                roughness: 0.2, metalness: 0.8
            });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, 0, z); snakeGroup.add(mesh);
            if(isHead) { 
                const light = new THREE.PointLight(currentThemeColor, 3, 15); 
                light.position.y = 2; mesh.add(light); 
            }
            snakeData.push({ mesh, currX: x, currZ: z, prevX: x, prevZ: z });
        }

        function spawnFood() {
            let valid = false, x, z;
            while(!valid) {
                x = Math.floor(Math.random()*GRID_SIZE*2) - GRID_SIZE; z = Math.floor(Math.random()*GRID_SIZE*2) - GRID_SIZE;
                valid = true; 
                for(let p of snakeData) if(Math.round(p.currX)===x && Math.round(p.currZ)===z) valid=false;
                for(let f of foodMeshes) if(Math.round(f.position.x)===x && Math.round(f.position.z)===z) valid=false;
            }
            const geo = new THREE.OctahedronGeometry(0.6, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0xff5500, emissiveIntensity: 3.0 });
            const mesh = new THREE.Mesh(geo, mat); mesh.position.set(x, 0.5, z);
            const light = new THREE.PointLight(0xff5500, 3, 10); mesh.add(light); scene.add(mesh);
            foodMeshes.push(mesh); 
            particles.explode(x, z, 0xffaa00, 5, 0.5);
        }

        function queueInput(turnAction) { if(inputQueue.length < 2) inputQueue.push(turnAction); }
        function onKeyDown(e) {
            if(!gameState.isPlaying) return;
            if(e.key === 'ArrowLeft') { queueInput('left'); lastTurnAction = 'left'; }
            else if(e.key === 'ArrowRight') { queueInput('right'); lastTurnAction = 'right'; }
            else if(e.key === 'ArrowDown') { if(lastTurnAction) queueInput(lastTurnAction); }
            else if(e.key === 'ArrowUp') gameState.isDashing = true;
        }
        function onKeyUp(e) { if(e.key === 'ArrowUp') gameState.isDashing = false; }

        function checkAdrenaline() {
            if(!gameState.isPlaying) return 1.0;
            const head = snakeData[0];
            let danger = false;
            let checkDir = direction.clone();
            if(inputQueue.length > 0) {
                 const axis = new THREE.Vector3(0, 1, 0);
                 const angle = (inputQueue[0] === 'left') ? Math.PI/2 : -Math.PI/2;
                 checkDir.applyAxisAngle(axis, angle);
                 checkDir.x = Math.round(checkDir.x); checkDir.z = Math.round(checkDir.z);
            }
            for(let i=1; i<=ADRENALINE_RANGE; i++) {
                const targetX = head.currX + checkDir.x * i;
                const targetZ = head.currZ + checkDir.z * i;
                if(Math.abs(targetX) > GRID_SIZE || Math.abs(targetZ) > GRID_SIZE) { danger = true; break; }
                for(let j=1; j<snakeData.length-1; j++) {
                    if(snakeData[j].currX === targetX && snakeData[j].currZ === targetZ) { danger = true; break; }
                }
            }
            return danger ? 0.2 : 1.0;
        }

        function updatePhase(score) {
            let pIdx = 0;
            for(let i=0; i<PHASES.length; i++) { if(score >= PHASES[i].score) pIdx = i; }
            if(gameState.phase !== pIdx + 1) {
                gameState.phase = pIdx + 1;
                const p = PHASES[pIdx];
                targetThemeColor.setHex(p.color);
                document.getElementById('phase-label').innerText = p.name;
                document.documentElement.style.setProperty('--theme-color', '#' + p.color.toString(16).padStart(6,'0'));
                scene.fog.color.setHex(p.fog);
                audioEngine.phase = gameState.phase;
            }
        }

        function updateFoodAlignment() {
            if (snakeData.length === 0) return;
            const head = snakeData[0].mesh;
            const headX = Math.round(head.position.x);
            const headZ = Math.round(head.position.z);

            foodMeshes.forEach(food => {
                const foodX = Math.round(food.position.x);
                const foodZ = Math.round(food.position.z);
                const aligned = (headX === foodX) || (headZ === foodZ);
                
                if (aligned) {
                    food.material.color.setHex(0x00ff00);
                    food.material.emissive.setHex(0x00ff00);
                    food.children[0].color.setHex(0x00ff00); 
                    food.scale.setScalar(1.3); 
                } else {
                    food.material.color.setHex(0xffaa00);
                    food.material.emissive.setHex(0xff5500);
                    food.children[0].color.setHex(0xff5500);
                    food.scale.setScalar(1.0);
                }
            });
        }

        function update(delta) {
            if(!gameState.isPlaying) { if(cityGroup) cityGroup.rotation.y += delta*0.05; return; }

            const targetAdrenaline = checkAdrenaline();
            adrenalineFactor = THREE.MathUtils.lerp(adrenalineFactor, targetAdrenaline, 0.1);
            filmPass.uniforms.grayscale.value = (1.0 - adrenalineFactor) * 1.5; 
            document.getElementById('adrenaline-overlay').style.opacity = (1.0 - adrenalineFactor);
            audioEngine.setAdrenaline(adrenalineFactor < 0.8);

            const slowDelta = delta * adrenalineFactor;

            let effectiveSpeed = BASE_SPEED;
            let isBoosting = false;
            if(gameState.isDashing && gameState.dashFuel > 0) {
                isBoosting = true; effectiveSpeed = BASE_SPEED / DASH_SPEED_MULT;
                gameState.dashFuel -= DASH_CONSUMPTION * slowDelta;
                if(gameState.dashFuel < 0) gameState.dashFuel = 0;
                updateDashUI();
                rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(rgbShiftPass.uniforms['amount'].value, 0.005, 0.1);
                const tail = snakeData[snakeData.length-1];
                if(Math.random() > 0.5) particles.explode(tail.currX, tail.currZ, currentThemeColor.getHex(), 1, 0.5);
            } else {
                rgbShiftPass.uniforms['amount'].value = THREE.MathUtils.lerp(rgbShiftPass.uniforms['amount'].value, 0.001, 0.1);
            }
            audioEngine.setDashState(isBoosting);

            moveTimer += slowDelta;
            if(moveTimer >= effectiveSpeed) { moveTimer = 0; tick(); }

            currentThemeColor.lerp(targetThemeColor, 0.01);
            gridHelper.material.color.copy(currentThemeColor);
            wallLines.material.color.copy(currentThemeColor);
            
            const progress = Math.min(moveTimer / effectiveSpeed, 1.0);
            
            // [HYBRID GRAPHICS] Phase-dependent snake intensity
            for(let i=0; i<snakeData.length; i++) {
                const p = snakeData[i];
                p.mesh.position.x = THREE.MathUtils.lerp(p.prevX, p.currX, progress);
                p.mesh.position.z = THREE.MathUtils.lerp(p.prevZ, p.currZ, progress);
                
                // Keep color sync
                if(p.mesh.material.emissive) p.mesh.material.emissive.copy(currentThemeColor);
                if(p.mesh.children.length > 0) p.mesh.children[0].color.copy(currentThemeColor);

                // Intensity Modulation based on Phase
                const isHead = (i===0);
                let targetInt;
                if (gameState.phase === 1) {
                    // Phase 1: Clean & Sharp (Low Bloom)
                    targetInt = isHead ? 1.0 : 0.4;
                } else {
                    // Phase 2+: Full Power Glow
                    targetInt = isHead ? 1.5 : 0.8;
                }
                // Smoothly update intensity
                p.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(p.mesh.material.emissiveIntensity, targetInt, 0.05);
            }

            updateCamera(progress, isBoosting, slowDelta);
            
            foodMeshes.forEach(mesh => {
                mesh.rotation.y += slowDelta*4;
                mesh.position.y = 0.5 + Math.sin(performance.now()*0.008)*0.2;
            });
            updateFoodAlignment();
            particles.update(slowDelta);
        }

        function tick() {
            if(inputQueue.length > 0) {
                const turnAction = inputQueue.shift();
                const axis = new THREE.Vector3(0, 1, 0);
                const angle = (turnAction === 'left') ? Math.PI/2 : -Math.PI/2;
                const newDir = direction.clone().applyAxisAngle(axis, angle);
                newDir.x = Math.round(newDir.x); newDir.z = Math.round(newDir.z);
                direction.copy(newDir);
            }
            const head = snakeData[0];
            const nx = head.currX + direction.x;
            const nz = head.currZ + direction.z;
            if(Math.abs(nx) > GRID_SIZE || Math.abs(nz) > GRID_SIZE) { gameOver(); return; }
            for(let i=0; i<snakeData.length-1; i++) { if(snakeData[i].currX === nx && snakeData[i].currZ === nz) { gameOver(); return; } }
            for(let p of snakeData) { p.prevX = p.currX; p.prevZ = p.currZ; }
            
            let eatenIndex = -1;
            for(let i=0; i<foodMeshes.length; i++) {
                const f = foodMeshes[i];
                if(Math.round(nx) === Math.round(f.position.x) && Math.round(nz) === Math.round(f.position.z)) {
                    eatenIndex = i;
                    break;
                }
            }

            if(eatenIndex !== -1) {
                gameState.score += 10; updatePhase(gameState.score);
                audioEngine.score = gameState.score; audioEngine.playSound('eat');
                particles.explode(nx, nz, 0xffaa00, 20, 2);
                if(gameState.dashFuel < MAX_DASH_FUEL) {
                    gameState.dashFuel += 1.0;
                    if(gameState.dashFuel > MAX_DASH_FUEL) gameState.dashFuel = MAX_DASH_FUEL;
                    updateDashUI();
                }
                updateScoreUI(); 
                scene.remove(foodMeshes[eatenIndex]);
                foodMeshes.splice(eatenIndex, 1);
                spawnFood();

                const tail = snakeData[snakeData.length-1]; addSnakePart(tail.prevX, tail.prevZ);
                const newTail = snakeData[snakeData.length-1]; newTail.prevX = tail.prevX; newTail.prevZ = tail.prevZ; newTail.currX = tail.prevX; newTail.currZ = tail.prevZ;
            }

            for(let i=snakeData.length-1; i>0; i--) { snakeData[i].currX = snakeData[i-1].currX; snakeData[i].currZ = snakeData[i-1].currZ; }
            head.currX = nx; head.currZ = nz;
        }

        function updateCamera(progress, isBoosting, delta) {
            if(snakeData.length === 0) return;
            const head = snakeData[0].mesh;
            const backVec = direction.clone().negate().normalize();
            
            const targetDist = isBoosting ? 20 : 14; const targetHeight = isBoosting ? 8 : 10; const targetFOV = isBoosting ? 110 : 85;
            camera.fov = THREE.MathUtils.lerp(camera.fov, targetFOV, 0.05); camera.updateProjectionMatrix();

            const targetPos = new THREE.Vector3();
            targetPos.copy(head.position).add(backVec.multiplyScalar(targetDist)).add(new THREE.Vector3(0, targetHeight, 0));
            const lookPos = new THREE.Vector3();
            lookPos.copy(head.position).add(direction.clone().multiplyScalar(15));
            if(isBoosting) { targetPos.x += (Math.random()-0.5)*0.2; targetPos.y += (Math.random()-0.5)*0.2; }
            
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(lookPos);
        }

        function updateScoreUI() { document.getElementById('score').innerText = gameState.score; }
        function updateDashUI() { for(let i=0; i<4; i++) { const c=document.getElementById(`cell-${i}`); if(gameState.dashFuel>i+1)c.style.width='100%'; else if(gameState.dashFuel>i)c.style.width=`${(gameState.dashFuel-i)*100}%`; else c.style.width='0%'; } }
        function gameOver() {
            gameState.isPlaying = false; audioEngine.stop();
            snakeData.forEach(p => { p.mesh.visible = false; particles.explode(p.currX, p.currZ, 0xff0000, 5, 1); });
            rgbShiftPass.uniforms['amount'].value = 0.02;
            document.getElementById('final-score').innerText = gameState.score;
            document.getElementById('game-over-screen').style.display = 'block';
        }
        function onResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight); }
        function animate() { requestAnimationFrame(animate); const now = performance.now(); const delta = (now - lastTime)/1000; lastTime = now; update(delta); composer.render(); }

        init();
    </script>
</body>
</html>
