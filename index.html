<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake: Hyper Wide</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Rajdhani', sans-serif;
            user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 20px;
            color: #fff;
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 0 10px #00f3ff;
            letter-spacing: 2px;
            display: flex;
            justify-content: space-between;
        }
        
        .hud span { color: #00f3ff; }
        .audio-indicator { font-size: 14px; color: #555; animation: pulse 2s infinite; }

        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; color: #ff0055; } 100% { opacity: 0.5; } }

        .center-panel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 5, 10, 0.9);
            border: 1px solid rgba(0, 243, 255, 0.5);
            padding: 50px 80px;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 80px rgba(0, 243, 255, 0.15), inset 0 0 30px rgba(0, 243, 255, 0.1);
            z-index: 50;
        }

        h1 {
            font-size: 60px;
            margin: 0 0 10px 0;
            font-weight: 800;
            font-style: italic;
            background: linear-gradient(90deg, #fff, #00f3ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: -2px;
        }

        p { color: #8899a6; font-size: 18px; margin-bottom: 40px; letter-spacing: 1px;}

        .btn {
            background: rgba(0, 243, 255, 0.1);
            border: 2px solid #00f3ff;
            color: #00f3ff;
            padding: 15px 50px;
            font-size: 24px;
            font-family: inherit;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        .btn:hover {
            background: #00f3ff;
            color: #000;
            box-shadow: 0 0 40px #00f3ff;
            transform: scale(1.05);
        }

        /* 모바일 컨트롤 영역 */
        #touch-area {
            display: none;
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 100%;
            pointer-events: auto;
            z-index: 10;
        }
        .touch-zone { width: 50%; height: 100%; float: left; }

        @media (max-width: 768px) {
            #touch-area { display: block; }
            h1 { font-size: 40px; }
            .center-panel { width: 85%; padding: 30px; }
            .btn { font-size: 18px; padding: 12px 30px; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud">
            <div>SCORE: <span id="score">0</span></div>
            <div class="audio-indicator">AUDIO SYSTEM ONLINE</div>
        </div>

        <div id="start-screen" class="center-panel">
            <h1>Neon Hyper</h1>
            <p>
                WIDE FOV // SURROUND SOUND<br>
                이어폰을 착용하고 시스템에 접속하십시오.
            </p>
            <button class="btn" id="btn-start">CONNECT</button>
        </div>

        <div id="game-over-screen" class="center-panel" style="display: none;">
            <h1 style="background: linear-gradient(90deg, #ff0055, #ff9900); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">DESYNCHRONIZED</h1>
            <p>DATA RECOVERED: <span id="final-score" style="color:#fff">0</span></p>
            <button class="btn" id="btn-restart" style="border-color: #ff0055; color: #ff0055;">RETRY</button>
        </div>

        <div id="touch-area">
            <div class="touch-zone" id="t-left"></div>
            <div class="touch-zone" id="t-right"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 사운드 엔진 (Synthwave Generator) ---
        class CyberSynth {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.4; // 전체 볼륨
                this.masterGain.connect(this.ctx.destination);
                
                this.isPlaying = false;
                this.nextNoteTime = 0;
                this.tempo = 110;
                this.beatCount = 0;
            }

            resume() {
                if(this.ctx.state === 'suspended') this.ctx.resume();
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime;
                this.scheduler();
            }

            stop() {
                this.isPlaying = false;
            }

            scheduler() {
                if(!this.isPlaying) return;
                const secondsPerBeat = 60.0 / this.tempo;
                const lookahead = 0.1; 

                while (this.nextNoteTime < this.ctx.currentTime + lookahead) {
                    this.playBeat(this.nextNoteTime, this.beatCount);
                    this.nextNoteTime += secondsPerBeat / 2; // 8분 음표 단위
                    this.beatCount++;
                }
                setTimeout(() => this.scheduler(), 25);
            }

            playBeat(time, beat) {
                const step = beat % 8; // 8 steps pattern
                
                // 1. KICK (쿵) - 1, 3, 5, 7 (4/4 정박)
                if (step % 4 === 0) {
                    this.playKick(time);
                    this.playBass(time, step === 0 ? 55 : 65); // Low A, then slightly higher
                }
                
                // 2. SNARE/CLAP (착) - 2.5, 6.5 (엇박 느낌)
                if (step === 4) {
                    this.playSnare(time);
                }

                // 3. HI-HAT (치칫) - Every step, with volume variation
                this.playHiHat(time, step % 2 === 0 ? 0.05 : 0.1);

                // 4. DRONE PAD (부웅-) - Loop every 16 beats
                if (beat % 32 === 0) {
                    this.playDrone(time);
                }
            }

            playKick(time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);

                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

                osc.start(time);
                osc.stop(time + 0.5);
            }

            playSnare(time) {
                // Noise buffer
                const bufferSize = this.ctx.sampleRate * 0.2; // 0.2 sec
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 1000;

                const gain = this.ctx.createGain();
                noise.connect(noiseFilter);
                noiseFilter.connect(gain);
                gain.connect(this.masterGain);

                gain.gain.setValueAtTime(0.5, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.start(time);
            }

            playHiHat(time, vol) {
                // High freq noise
                const bufferSize = this.ctx.sampleRate * 0.05;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000;

                const gain = this.ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                noise.start(time);
            }

            playBass(time, freq) {
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                
                const gain = this.ctx.createGain();
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.frequency.setValueAtTime(freq, time);
                // "Womp" effect filter
                filter.frequency.setValueAtTime(100, time);
                filter.frequency.exponentialRampToValueAtTime(800, time + 0.1);
                filter.frequency.exponentialRampToValueAtTime(100, time + 0.3);

                gain.gain.setValueAtTime(0.4, time);
                gain.gain.linearRampToValueAtTime(0, time + 0.4);

                osc.start(time);
                osc.stop(time + 0.4);
            }

            playDrone(time) {
                // Grand atmosphere pad
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                osc1.type = 'sawtooth';
                osc2.type = 'sawtooth';

                // Detune for chorus effect
                osc1.frequency.value = 55; // A1
                osc2.frequency.value = 55.5; 

                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.2, time + 2); // Slow attack
                gain.gain.linearRampToValueAtTime(0, time + 8); // Long release

                osc1.start(time);
                osc2.start(time);
                osc1.stop(time + 8);
                osc2.stop(time + 8);
            }

            playEatEffect() {
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                // High pitched bling
                osc.frequency.setValueAtTime(880, t);
                osc.frequency.exponentialRampToValueAtTime(1760, t + 0.1);
                
                gain.gain.setValueAtTime(0.3, t);
                gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                
                osc.start(t); osc.stop(t + 0.1);
            }
        }


        // --- 게임 설정 ---
        const GRID_SIZE = 30; // 맵 더 넓힘
        const TILE_SIZE = 1;
        const SPEED_BASE = 0.08; // 기본 속도 상향 (0.15 -> 0.08)
        
        let currentSpeed = SPEED_BASE;
        let scene, camera, renderer, composer;
        let snakeGroup, foodMesh;
        let snakeData = []; 
        let direction = new THREE.Vector3(0, 0, -1);
        let nextDirection = new THREE.Vector3(0, 0, -1);
        
        let lastTime = 0;
        let moveTimer = 0;
        let isPlaying = false;
        let score = 0;
        let soundEngine;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);
            // 안개 거리 조정 (더 멀리 보이게)
            scene.fog = new THREE.Fog(0x020205, 20, 90);

            // [핵심 변경] 광각 카메라 (FOV 85)
            camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 200);
            
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Bloom
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.strength = 2.0; // 더 강한 빛
            bloomPass.radius = 0.3;
            bloomPass.threshold = 0.1;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0x404040, 0.5));
            createArena();

            snakeGroup = new THREE.Group();
            scene.add(snakeGroup);

            soundEngine = new CyberSynth();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            
            document.getElementById('btn-start').addEventListener('click', startGame);
            document.getElementById('btn-restart').addEventListener('click', startGame);
            
            // 모바일 터치
            const tLeft = document.getElementById('t-left');
            const tRight = document.getElementById('t-right');
            const handleTouch = (dir) => { if(isPlaying) turn(dir); };
            tLeft.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('left'); });
            tRight.addEventListener('touchstart', (e) => { e.preventDefault(); handleTouch('right'); });

            animate();
        }

        function createArena() {
            // 끝없이 펼쳐지는 바닥 느낌
            const gridHelper = new THREE.GridHelper(GRID_SIZE * 4, GRID_SIZE * 2, 0x1a1a2e, 0x0a0a10);
            gridHelper.position.y = -0.5;
            scene.add(gridHelper);

            // 경계선 (네온 벽)
            const geometry = new THREE.BoxGeometry(GRID_SIZE * 2, 4, GRID_SIZE * 2);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ color: 0xff0088, linewidth: 2 });
            const walls = new THREE.LineSegments(edges, material);
            walls.position.y = 1.5;
            scene.add(walls);
        }

        function startGame() {
            soundEngine.resume();
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';

            score = 0;
            updateUI();
            currentSpeed = SPEED_BASE;
            
            while(snakeGroup.children.length > 0) snakeGroup.remove(snakeGroup.children[0]);
            snakeData = [];
            
            addSnakePart(0, 0); 
            addSnakePart(0, 1); 
            addSnakePart(0, 2); 
            addSnakePart(0, 3); 
            addSnakePart(0, 4); // 좀 더 길게 시작

            direction.set(0, 0, -1);
            nextDirection.copy(direction);

            moveTimer = 0;
            lastTime = performance.now();
            
            spawnFood();
            isPlaying = true;
        }

        function addSnakePart(x, z) {
            const geometry = new THREE.BoxGeometry(0.9, 0.9, 0.9);
            const isHead = snakeData.length === 0;
            const material = new THREE.MeshStandardMaterial({
                color: isHead ? 0xffffff : 0x00f3ff,
                emissive: isHead ? 0xffffff : 0x0088ff,
                emissiveIntensity: isHead ? 1.0 : 0.8,
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0, z);
            snakeGroup.add(mesh);
            
            if (isHead) {
                // 헤드라이트 거리 증가
                const light = new THREE.PointLight(0x00f3ff, 5, 40); 
                light.position.y = 2;
                mesh.add(light);
            }
            snakeData.push({ mesh, currX: x, currZ: z, prevX: x, prevZ: z });
        }

        function spawnFood() {
            if (foodMesh) scene.remove(foodMesh);
            let valid = false, x, z;
            while(!valid) {
                x = Math.floor(Math.random() * (GRID_SIZE * 2)) - GRID_SIZE;
                z = Math.floor(Math.random() * (GRID_SIZE * 2)) - GRID_SIZE;
                valid = true;
                for(let p of snakeData) if(Math.round(p.currX) === x && Math.round(p.currZ) === z) valid = false;
            }

            // 먹이 디자인 변경 (떠있는 피라미드)
            const geometry = new THREE.ConeGeometry(0.5, 1, 4);
            const material = new THREE.MeshStandardMaterial({
                color: 0xff9900, emissive: 0xff5500, emissiveIntensity: 3.0
            });
            foodMesh = new THREE.Mesh(geometry, material);
            foodMesh.position.set(x, 0.5, z);
            scene.add(foodMesh);
        }

        function turn(side) {
            const axis = new THREE.Vector3(0, 1, 0);
            const angle = (side === 'left') ? Math.PI / 2 : -Math.PI / 2;
            const newDir = direction.clone().applyAxisAngle(axis, angle);
            newDir.x = Math.round(newDir.x); newDir.z = Math.round(newDir.z);
            nextDirection.copy(newDir);
        }

        function onKeyDown(e) {
            if (!isPlaying) return;
            if (e.key === 'ArrowLeft') turn('left');
            if (e.key === 'ArrowRight') turn('right');
        }

        function update(delta) {
            if (!isPlaying) return;
            moveTimer += delta;
            
            if (moveTimer >= currentSpeed) {
                moveTimer = 0;
                tick();
            }

            const progress = Math.min(moveTimer / currentSpeed, 1.0);
            for (let part of snakeData) {
                part.mesh.position.x = THREE.MathUtils.lerp(part.prevX, part.currX, progress);
                part.mesh.position.z = THREE.MathUtils.lerp(part.prevZ, part.currZ, progress);
            }
            updateCamera(progress);

            if(foodMesh) {
                foodMesh.rotation.y += delta * 5;
                foodMesh.position.y = 0.5 + Math.sin(performance.now() * 0.01) * 0.3;
            }
        }

        function tick() {
            direction.copy(nextDirection);
            const head = snakeData[0];
            const nextX = head.currX + direction.x;
            const nextZ = head.currZ + direction.z;

            if (Math.abs(nextX) > GRID_SIZE || Math.abs(nextZ) > GRID_SIZE) { gameOver(); return; }
            for (let i = 0; i < snakeData.length - 1; i++) {
                if (snakeData[i].currX === nextX && snakeData[i].currZ === nextZ) { gameOver(); return; }
            }

            for (let part of snakeData) { part.prevX = part.currX; part.prevZ = part.currZ; }

            let ate = false;
            if (foodMesh && Math.round(nextX) === Math.round(foodMesh.position.x) && Math.round(nextZ) === Math.round(foodMesh.position.z)) {
                ate = true;
                score += 10;
                updateUI();
                soundEngine.playEatEffect();
                spawnFood();
                currentSpeed = Math.max(0.04, currentSpeed * 0.98); // 속도 제한선 설정
            }

            if (ate) {
                const tail = snakeData[snakeData.length - 1];
                addSnakePart(tail.prevX, tail.prevZ);
                const newTail = snakeData[snakeData.length - 1];
                newTail.prevX = tail.prevX; newTail.prevZ = tail.prevZ;
                newTail.currX = tail.prevX; newTail.currZ = tail.prevZ;
            }

            for (let i = snakeData.length - 1; i > 0; i--) {
                snakeData[i].currX = snakeData[i - 1].currX;
                snakeData[i].currZ = snakeData[i - 1].currZ;
            }
            head.currX = nextX; head.currZ = nextZ;
        }

        function updateCamera(progress) {
            if (snakeData.length === 0) return;
            const head = snakeData[0].mesh;
            
            // [핵심 변경] 카메라 거리와 각도 조절
            // 이전보다 훨씬 뒤(16)에서, 조금 더 높게(12) 
            const backVec = direction.clone().negate().normalize();
            const targetPos = new THREE.Vector3();
            // dist: 16 (멀리), height: 12 (위에서)
            targetPos.copy(head.position).add(backVec.multiplyScalar(16)).add(new THREE.Vector3(0, 12, 0));
            
            // 카메라는 머리보다 훨씬 앞을 내다봄 (LookAhead: 15)
            const lookPos = new THREE.Vector3();
            lookPos.copy(head.position).add(direction.clone().multiplyScalar(15));

            // Lerp 속도를 낮춰서(0.08) 카메라가 더 부드럽게 '끌려오는' 느낌 (드리프트감)
            camera.position.lerp(targetPos, 0.08);
            camera.lookAt(lookPos);
        }

        function gameOver() {
            isPlaying = false;
            soundEngine.stop();
            // 게임오버 사운드 (간단한 노이즈)
            const t = soundEngine.ctx.currentTime;
            const osc = soundEngine.ctx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(10, t+1);
            const gain = soundEngine.ctx.createGain();
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.linearRampToValueAtTime(0, t+1);
            osc.connect(gain); gain.connect(soundEngine.ctx.destination);
            osc.start(t); osc.stop(t+1);

            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'block';
        }

        function updateUI() { document.getElementById('score').innerText = score; }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;
            update(delta);
            composer.render();
        }

        init();
    </script>
</body>
</html>
