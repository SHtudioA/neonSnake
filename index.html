<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Snake: Cyberpunk Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            touch-action: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.1);
        }

        canvas {
            display: block;
            background: #000;
            border: 2px solid #333;
        }

        .scanline {
            width: 100%;
            height: 100%;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 50%, rgba(0, 255, 255, 0.02) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
            background-size: 100% 2px, 3px 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 20px;
            color: #00f3ff;
            text-shadow: 0 0 10px #00f3ff;
            z-index: 20;
        }

        .high-score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 20px;
            color: #ff0055;
            text-shadow: 0 0 10px #ff0055;
            z-index: 20;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(5, 5, 5, 0.9);
            padding: 40px;
            border: 1px solid #00f3ff;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            z-index: 30;
            pointer-events: auto;
            min-width: 280px;
        }

        h1 {
            margin: 0 0 10px 0;
            font-size: 40px;
            color: #00f3ff;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.8);
            letter-spacing: 2px;
        }

        p {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 30px;
            line-height: 1.5;
        }

        button.cyber-btn {
            background: transparent;
            color: #00f3ff;
            border: 2px solid #00f3ff;
            padding: 15px 40px;
            font-size: 18px;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
        }

        button.cyber-btn:hover {
            background: #00f3ff;
            color: #000;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.6);
        }

        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 180px;
            pointer-events: auto;
            display: none;
            z-index: 40;
        }

        .d-pad {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .ctrl-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(0, 243, 255, 0.1);
            border: 1px solid rgba(0, 243, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: #00f3ff;
            user-select: none;
            cursor: pointer;
            backdrop-filter: blur(2px);
        }

        .ctrl-btn:active {
            background: rgba(0, 243, 255, 0.4);
            box-shadow: 0 0 15px #00f3ff;
        }

        .btn-up { top: 0; left: 50%; transform: translateX(-50%); }
        .btn-down { bottom: 0; left: 50%; transform: translateX(-50%); }
        .btn-left { top: 50%; left: 0; transform: translateY(-50%); }
        .btn-right { top: 50%; right: 0; transform: translateY(-50%); }

        @media (max-width: 768px) {
            #mobile-controls { display: block; }
            h1 { font-size: 32px; }
            .hud, .high-score { font-size: 16px; }
            canvas { border: none; }
            #game-container { box-shadow: none; width: 100%; height: 100%; }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="scanline"></div>
        
        <div id="ui-layer">
            <div class="hud">SCORE: <span id="score">0</span></div>
            <div class="high-score">BEST: <span id="best">0</span></div>

            <div id="start-screen">
                <h1>NEON SNAKE</h1>
                <p>CYBERPUNK EDITION<br>방향키로 이동하여 에너지 코어를 획득하세요.</p>
                <button class="cyber-btn" onclick="startGame()">SYSTEM LINK</button>
            </div>

            <div id="game-over-screen" style="display: none;">
                <h1 style="color: #ff0055; text-shadow: 0 0 10px #ff0055;">CRITICAL ERROR</h1>
                <p>SYSTEM CRASHED<br>FINAL SCORE: <span id="final-score">0</span></p>
                <button class="cyber-btn" style="border-color: #ff0055; color: #ff0055;" onclick="startGame()">REBOOT</button>
            </div>

            <div id="mobile-controls">
                <div class="d-pad">
                    <div class="ctrl-btn btn-up" data-dir="up">▲</div>
                    <div class="ctrl-btn btn-left" data-dir="left">◀</div>
                    <div class="ctrl-btn btn-right" data-dir="right">▶</div>
                    <div class="ctrl-btn btn-down" data-dir="down">▼</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const TILE_SIZE = 20;
        const GRID_COLOR = '#1a1a1a';
        const SNAKE_COLOR = '#00f3ff';
        const FOOD_COLOR = '#ff0055';
        
        let tileCountX = 20;
        let tileCountY = 20;
        let score = 0;
        let highScore = localStorage.getItem('neonSnakeHighScore') || 0;
        
        let velocity = { x: 0, y: 0 };
        let snake = [];
        let food = { x: 10, y: 10 };
        let particles = [];
        
        let gameLoopId;
        let lastTime = 0;
        let gameSpeed = 100;
        let lastRenderTime = 0;
        let isGameRunning = false;
        
        let inputQueue = [];

        function resize() {
            if (window.innerWidth <= 768) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            } else {
                canvas.width = 600;
                canvas.height = 600;
            }

            tileCountX = Math.floor(canvas.width / TILE_SIZE);
            tileCountY = Math.floor(canvas.height / TILE_SIZE);
            
            canvas.width = tileCountX * TILE_SIZE;
            canvas.height = tileCountY * TILE_SIZE;
        }
        
        window.addEventListener('resize', () => {
            resize();
            if(!isGameRunning && document.getElementById('start-screen').style.display !== 'none') {
                draw();
            }
        });
        resize();
        document.getElementById('best').innerText = highScore;

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playTone(freq, type, duration) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playEatSound() {
            playTone(600, 'square', 0.1);
            setTimeout(() => playTone(1200, 'square', 0.1), 50);
        }

        function playDieSound() {
            playTone(200, 'sawtooth', 0.5);
            playTone(150, 'sawtooth', 0.5);
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            
            score = 0;
            gameSpeed = 100;
            updateScore();
            
            snake = [
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) },
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) + 1 },
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) + 2 }
            ];
            velocity = { x: 0, y: -1 }; 
            inputQueue = [];
            
            placeFood();
            isGameRunning = true;
            lastTime = performance.now();
            window.requestAnimationFrame(mainLoop);
        }

        function mainLoop(currentTime) {
            if (!isGameRunning) return;

            window.requestAnimationFrame(mainLoop);

            const secondsSinceLastRender = (currentTime - lastRenderTime) / 1000;
            
  
            if (currentTime - lastTime > gameSpeed) {
                lastTime = currentTime;
                update();
            }
            
            draw();
            updateParticles();
        }

        function update() {

            if (inputQueue.length > 0) {
                const nextDir = inputQueue.shift();

                if (
                    (nextDir.x === 1 && velocity.x !== -1) ||
                    (nextDir.x === -1 && velocity.x !== 1) ||
                    (nextDir.y === 1 && velocity.y !== -1) ||
                    (nextDir.y === -1 && velocity.y !== 1)
                ) {
                    velocity = nextDir;
                } else if (inputQueue.length > 0) {

                }
            }

            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                gameOver();
                return;
            }


            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                if (gameSpeed > 40) gameSpeed -= 1; 
                
                updateScore();
                playEatSound();
                createParticles(head.x * TILE_SIZE + TILE_SIZE/2, head.y * TILE_SIZE + TILE_SIZE/2, FOOD_COLOR);
                placeFood();
            } else {
                snake.pop(); 
            }
        }

        function placeFood() {
            let valid = false;
            while (!valid) {
                food.x = Math.floor(Math.random() * tileCountX);
                food.y = Math.floor(Math.random() * tileCountY);
                
                valid = true;
                for (let part of snake) {
                    if (part.x === food.x && part.y === food.y) {
                        valid = false;
                        break;
                    }
                }
            }
        }

        function gameOver() {
            isGameRunning = false;
            playDieSound();
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('neonSnakeHighScore', highScore);
                document.getElementById('best').innerText = highScore;
            }
            
            document.getElementById('final-score').innerText = score;
            document.getElementById('game-over-screen').style.display = 'block';
        }

        function updateScore() {
            document.getElementById('score').innerText = score;
        

        function draw() {
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = GRID_COLOR;
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= canvas.width; x += TILE_SIZE) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = 0; y <= canvas.height; y += TILE_SIZE) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();

            drawGlowRect(food.x, food.y, FOOD_COLOR, true);

            snake.forEach((part, index) => {
                const isHead = index === 0;
                drawGlowRect(part.x, part.y, SNAKE_COLOR, isHead);
            });
            
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1.0;
            });
        }

        function drawGlowRect(x, y, color, pulse) {
            const px = x * TILE_SIZE;
            const py = y * TILE_SIZE;
            const padding = 2;

            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;

            if (pulse) {
                const flicker = Math.random() * 0.2 + 0.8;
                ctx.globalAlpha = flicker;
            }

            ctx.fillRect(px + padding, py + padding, TILE_SIZE - padding * 2, TILE_SIZE - padding * 2);
            
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.5;
            const corePadding = 6;
            ctx.fillRect(px + corePadding, py + corePadding, TILE_SIZE - corePadding * 2, TILE_SIZE - corePadding * 2);

            ctx.globalAlpha = 1.0;
        }

        
        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 1.0,
                    color: color,
                    size: Math.random() * 3 + 2
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }


        function handleInput(dir) {
            if (inputQueue.length >= 2) return;
            
            const lastDir = inputQueue.length > 0 ? inputQueue[inputQueue.length - 1] : velocity;
            
            if (dir.x !== 0 && lastDir.x !== 0) return; 
            if (dir.y !== 0 && lastDir.y !== 0) return; 

            inputQueue.push(dir);
        }

        window.addEventListener('keydown', e => {
            if (!isGameRunning) return;
            switch (e.key) {
                case 'ArrowUp': handleInput({x: 0, y: -1}); break;
                case 'ArrowDown': handleInput({x: 0, y: 1}); break;
                case 'ArrowLeft': handleInput({x: -1, y: 0}); break;
                case 'ArrowRight': handleInput({x: 1, y: 0}); break;
            }
        });

        const touchBtns = document.querySelectorAll('.ctrl-btn');
        touchBtns.forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isGameRunning) return;
                const dir = btn.getAttribute('data-dir');
                if (dir === 'up') handleInput({x: 0, y: -1});
                if (dir === 'down') handleInput({x: 0, y: 1});
                if (dir === 'left') handleInput({x: -1, y: 0});
                if (dir === 'right') handleInput({x: 1, y: 0});
            }, { passive: false });
        });

        draw();

    </script>
</body>
</html>
